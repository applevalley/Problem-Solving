# 이전 작동에서 k광년을 이동했다면 다음 작동에서는 k - 1, k, k + 1광년만을 이동할 수 있다.
# x지점에서 y지점까지 최소한의 작동 횟수로 이동해야 하는데, y지점에 도착하기 바로 직전의 이동거리는 반드시 1광년이다.
# 이동의 최솟값은 얼마일까?

# x는 항상 y보다 작다. 그리고 입력받을 수 있는 y의 최댓값은 2^31 - 1이다.
# 데이터의 크기로 짐작하건데 최대한 상수 시간에 가깝게 풀지 않는다면 시간 초과가 날 것으로 보인다.
# 아무리 생각해도 규칙을 찾아낼 수 없었기에 어느 정도의 데이터를 직접 만들어보면서 규칙을 찾아보기로 했다.

# 0 -> 1 : 1
# 0 -> 2 : 1 1
# 0 -> 3 : 1 1 1
# 0 -> 4 : 1 2 1
# 0 -> 5 : 1 2 1 1
# 0 -> 6 : 1 2 2 1
# 0 -> 7 : 1 2 2 1 1
# 0 -> 8 : 1 2 2 2 1
# 0 -> 9 : 1 2 3 2 1
# 0 -> 10 : 1 2 3 2 1 1
# 0 -> 11 : 1 2 3 2 2 1
# 0 -> 12 : 1 2 3 3 2 1
# 0 -> 13 : 1 2 3 3 2 1 1
# 0 -> 14 : 1 2 3 3 2 2 1
# 0 -> 15 : 1 2 3 3 3 2 1
# 0 -> 16 : 1 2 3 4 3 2 1
# 0 -> 17 : 1 2 3 4 3 2 1 1
# 0 -> 18 : 1 2 3 4 3 2 2 1
# 0 -> 19 : 1 2 3 4 3 3 2 1
# 0 -> 20 : 1 2 3 4 4 3 2 1
# 0 -> 21 : 1 2 3 4 4 3 2 1 1
# 0 -> 22 : 1 2 3 4 4 3 3 2 1
# 0 -> 23 : 1 2 3 4 4 3 3 2 1
# 0 -> 24 : 1 2 3 4 4 4 3 2 1
# 0 -> 25 : 1 2 3 4 5 4 3 2 1

# 문제에서의 제한 범위에 비하면 매우 작은 범위의 데이터지만, 규칙적으로 늘어나는 수를 보며 겨우 일련의 규칙을 알게 되었다.
# n ** 2에 해당되는 숫자(1, 4, 9, 16, ..)의 경우 2 * 루트 n에서 1을 뺀 수,
# 그 외의 경우에는 2 * 루트 n에서 소수부를 제거한 정수가 된다.


import math

for test_case in range(int(input())):
    x, y = map(int, input().split())
    distance = y - x
    ans = 0
    root = math.sqrt(distance)

    if root == int(root):
        ans = (2 * int(root)) - 1
    else:
        ans = int(2 * root)
    print(ans)
