# 일직선 도로의 가장 왼쪽 도시에서 가장 오른쪽 도시로 이동한다. 두 도시 사이의 도로는 서로 길이가 다를 수 있다.
# 1km당 1리터의 기름을 사용하며, 가장 첫 도시에서 기름을 충전한 뒤 출발한다.
# 도시마다 기름값이 다르다. 끝에서 끝까지 이동하는 비용의 최솟값은?

# 첫 도시에서는 무조건 기름을 충전해야 한다.
# 만약 첫 도시의 기름값이 제일 싸다면 거기서 전체 길이만큼 충전을 해도 된다.
# 반대로 가장 비싸거나, 비싼 편이라면 첫 도시에서는 바로 다음 도시, 혹은 그 뒤의 도시로 이동할 만큼만 충전하는 것이 유리하다.
# 굳이 정렬을 하지 않아도 될 것으로 보인다.
# 첫 도시에서부터 시작해 순회하되, i번 도시의 기름값을 하나의 기준으로 둔다.
# 그 다음 방문할 i + 1번 도시의 기름값이 기준값인 i번 도시의 기름값보다 비싸다면, i + 1번 도시에서 충전을 할 필요가 없다.
# i + 1번 도시에서 i + 2번 도시로 이동할 비용까지 i번 도시에서 충전하는 것이 더 저렴하다.

# 이 과정을 i번 도시의 순회에서 i번 도시보다 기름값이 작은 도시를 구하는 내부 반복문을 추가로 넣어서 한번에 진행할 수도 있다.
# 하지만 그럴 경우 최악의 경우를 가정했을 때 O(N^2)까지 복잡도가 커질 위험이 있고, 시간 초과의 가능성이 있다.
# 따라서 매 순회마다 비교하게 해서 O(N) 정도로 복잡도를 줄이는 것이 중요하다.

# 도시의 수는 최대 10만개이고, 시간 제한은 2초이다.
# 위를 따라 구현하면 기본적으로 반복문이 모든 도시를 순회하기 때문에 O(N)정도로 구현이 가능하다!

import sys
N = int(sys.stdin.readline().rstrip())                # 도시 수
distance = list(map(int, sys.stdin.readline().split()))   # 도시간 거리
fuel = list(map(int, sys.stdin.readline().split()))       # 도시별 기름값
ans = 0
fuel_standard = fuel[0]

for i in range(N - 1):             # 마지막 도시는 의미가 없다.
    if fuel_standard < fuel[i]:    # 이전 도시의 기름값보다 더 비싸서 충전 없이 건너뛰는 경우
        ans += (fuel_standard * distance[i])  # 기존의 저렴한 도시에서의 기름값에 다음 도시로의 거리를 곱해 더한다
        continue

    fuel_standard = fuel[i]        # 기름값이 더 저렴한 도시에 방문한 경우 기름값의 기준을 현재 방문한 도시의 기름값으로 변경
    ans += (fuel_standard * distance[i])  # 다음 도시로의 거리를 전체 비용에 더해준다.

print(ans)