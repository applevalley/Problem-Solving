# 캠핑장은 연속하는 P일 중 L일만 사용이 가능하다.
# V일간의 휴가 중 최대 며칠동안이나 사용이 가능할까?

# 다행히도 일정 사이사이 휴식일같이 아예 전체 휴가 일정에서 제외해야 하거나, P일 중 특정 요일은 사용이 불가능한 변수가 전혀 없다.
# 단순히 V일간의 휴가가 P일간격으로 계속 이어지는 형태일 것이다.
# L = 5, P = 8, V = 20이라면, 8일의 캠핑장 사용 기간은 20일간의 휴가 일정에 걸쳐 계속 이어진다.
# 8일 중 5일만 사용할 수 있기에, 20일간 캠핑장은 8 + 8 + 4의 형태로 운영되며,
# 이 기간동안 사용이 가능한 날들은 5 + 5 + 4이다. (8일 중 5일을 이용 가능한데, 사용 가능한 요일을 특정하지 않았기에 4일을 전부 쓸 수 있다!)
# 따라서 최대 이용 가능한 일수는 14가 될 것이다.
# 또 친절하게도 1 < L < P < V 라는 조건을 주었다. 여기서 부등호가 같거나 큰 관계가 아닌 단순히 큰 관계로만 구성된 것이 중요하다.

cnt = 1

while True:
    L, P, V = map(int, input().split())

    if L == P == V == 0:     # 마지막 입력이 들어오면 탈출
        break

# 여기서 잠시 생각해보자
# V는 P보다 반드시 크기에, P일의 휴가 중 V일간 캠핑장이 n번 열렸다면, 그 요일을 제외한 (V % P)일만큼의 기간이 남게 된다.
# 과연 이 (V % P)는 L보다 크거나 같을까(같을 때는 V가 P의 배수일 경우)? 아니면 더 작을까?
# 크거나 같은 경우, 남은 기간동안 L일간 캠핑장을 온전히 사용할 수 있다.
# 작은 경우, 남은 기간동안 L일을 전부 사용할 수 없고 (V % P)일이 추가로 이용할 수 있는 최대가 된다.
# 따라서 이용이 가능한 최대 일수는 (L * (V // P))에 조건에 따라 L이나 (V % P)를 더한 수가 된다.
# 시간 복잡도는 상수 시간이다.

    if (V % P) >= L:
        ans = ((L * (V // P)) + L)
    else:
        ans = ((L * (V // P)) + (V % P))

    print(f'Case {cnt}: {ans}')
    cnt += 1