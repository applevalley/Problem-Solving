# 달팽이는 V미터인 나무 막대를 오른다.
# 낮에 A미터 올라가는데, 밤에는 B미터 미끄러진다. 정상에 도착하면 안 미끄러진다.
# 정상까지 가려면 며칠이 걸릴까?

# 시간 제한 0.15초.. 매우 짧다!
# 단순히 반복문을 돌려서 A만큼 올렸다가 B만큼 빼고 정상과 비교해서 반복된 횟수를 계산하는 식으로는 시간초과를 피할 수 없어보인다.
# 어떻게 간편하게 만들 수 있을까? 최소한의 연산을 통해 O(N)이 아닌 상수 시간의 복잡도가 필요하다.

# 1일차에 달팽이는 A만큼 올라간다.
# 2일차에 달팽이는 B만큼 내려오지만, 다시 A만큼 올라간다.
# (A - B) + A 로 나타낼 수 있다.
# 3일차면 어떨까?
# (A - B) + (A - B) + A가 된다!
# 이렇게 쭉쭉.. 정상까지 갈 것이다. 이걸 조금 예쁘게 다듬으면?
# ((A - B) * (n - 1)) + A가 되지 않을까?

# 이제 필요한 n이 얼마인지 알았다! 하지만 저것만으로는 어렵다.
# 반복문을 돌려서 n을 찾아야 할텐데 최대 높이는 10억이다.
# 조건에 따라 거의 10억에 가깝게 돌아야 한다는 것을 의미한다. 0.15초에서는 불가능하다.
# 조금 더 간편한 방법이 없을까?

# 나눗셈은 어떨까?

import sys

A, B, V = map(int, sys.stdin.readline().split())

# 달팽이가 도달해야 하는 명목상의 거리는 V이지만, 실제 주목해야 할 높이로는 V - B 정도가 될 것이다.
# V - B 높이에 도달만 하면, A의 값에 따라 바로 정상에 올라가거나, 하루만 더 있으면 오르게 된다.
# 그러면 이 높이까지 오려면 며칠이 필요한지는 어떻게 알 수 있을까?
# V - B 를 A - B로 나눠보면 알 수 있을 것이다.
res = (V - B) / (A - B)

# res는 float형이다! 다만 정수로 딱 나누어졌다면 int(res)와 res는 같은 값일 것이다.
# 만약 정수가 아니라면(부동소수점에 소수부가 존재한다면) 이는 목표 높이에 도달하지 못한 것을 의미한다.
# 결국 달팽이는 하루 더 올라가야 한다.
if res != int(res):
    res += 1

print(int(res)) # 정수형으로 출력해주자!