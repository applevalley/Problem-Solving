'''
1부터 n까지ㅣ 번호가 붙은 카드들이 있다
1번 카드가 제일 위에, n번 카드가 제일 아래인 상태
제일 위의 카드를 버린 뒤, 또 제일 위의 카드를 제일 아래의 카드 밑으로 옮긴다.

1234가 있으면 제일 위인 1번을 버리고, 다음 위인 2번을 제일 아래인 4번 밑으로 넣는 것
결과는 1234 -> 234 -> 342
한번 더 하면?
342 -> 42 -> 24
여기서 한번을 더 하면 2가 버려지고, 4 하나만 남는다.

이렇게 가장 마지막에 남게 되는 카드는?

단순하게 접근하면 시간 초과가 날거같은데....
매번 pop(0)한 뒤, pop(0)을 해서 append()를 한다면?
한 루프에서 이미 O(N)이 두번 발생한다.
N의 최댓값은 50만... 진작에 시간 초과가 난다.

트릭을 이용하면?
N이 6일 때, 큐는 [1, 2, 3, 4, 5, 6]이 들어있다.
1을 제거하고, 2를 가장 뒤로 보내면 [3, 4, 5, 6, 2]
3을 제거하고, 4를 가장 뒤로 보내면 [5, 6, 2, 4]
5를 제거하고, 6을 가장 뒤로 보내면 [2, 4, 6]

N이 7일 때, 큐는 [1, 2, 3, 4, 5, 6, 7]이 들어있다.
1을 제거하고, 2를 가장 뒤로 보내면 [3, 4, 5, 6, 7, 2]
3을 제거하고, 4를 가장 뒤로 보내면 [5, 6, 7, 2, 4]
5를 제거하고, 6을 가장 뒤로 보내면 [7, 2, 4, 6]

일련의 규칙을 발견할 수 있다!
N이 짝수일 때, 한 루프를 통해 큐의 길이는 N // 2으로 줄고, 기존 큐에서의 짝수 번째의 요소만이 살아남는다.
N이 홀수일 때, 한 루프를 통해 큐의 길이는 (N // 2) + 1으로 줄고, 기존 큐의 가장 마지막 요소 + 기존 큐에서의 짝수 번째 요소만이 살아남는다.

이러한 연산 과정을 큐의 길이가 1보다 같아질 때까지 계속 수행하면 마지막으로 큐에 남게 되는 요소가 무엇인지 구할 수 있게 된다!
이렇게 해나가면 O(log N)의 복잡도로 풀어낼 수 있지 않을까..?
'''

N = int(input())

Q = [i for i in range(1, N + 1)]

while len(Q) > 1:
    if len(Q) % 2:
        Q = [Q.pop()] + [Q[i] for i in range(len(Q)) if i % 2]
    else:
        Q = [Q[i] for i in range(len(Q)) if i % 2]

print(*Q)


'''
1 2 3 4 5 6 7 8 9 10

3 4 5 6 7 8 9 10 2
5 6 7 8 9 10 2 4
7 8 9 10 2 4 6
9 10 2 4 6 8
2 4 6 8 10

6 8 10 4
10 4 8

8 4

4


1 2 3 4 5 6 7

3 4 5 6 7 2
5 6 7 2 4
7 2 4 6

4 6 2
2 6

6

1 2 3 4 5

3 4 5 2
5 2 4
'''